var S=Object.defineProperty;var p=Object.getOwnPropertySymbols;var T=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var v=(e,o,t)=>o in e?S(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t,b=(e,o)=>{for(var t in o||(o={}))T.call(o,t)&&v(e,t,o[t]);if(p)for(var t of p(o))x.call(o,t)&&v(e,t,o[t]);return e};import{c as C,w as O,af as P,p as w,o as E,aR as M,aO as y,aV as z,aW as Q,g as V}from"./index.7efcbe86.js";const{passive:h}=y,A=["both","horizontal","vertical"];var N=C({name:"QScrollObserver",props:{axis:{type:String,validator:e=>A.includes(e),default:"vertical"},debounce:[String,Number],scrollTarget:{default:void 0}},emits:["scroll"],setup(e,{emit:o}){const t={position:{top:0,left:0},direction:"down",directionChanged:!1,delta:{top:0,left:0},inflectionPoint:{top:0,left:0}};let i=null,l,u;O(()=>e.scrollTarget,()=>{f(),d()});function s(){i!==null&&i();const a=Math.max(0,z(l)),c=Q(l),n={top:a-t.position.top,left:c-t.position.left};if(e.axis==="vertical"&&n.top===0||e.axis==="horizontal"&&n.left===0)return;const m=Math.abs(n.top)>=Math.abs(n.left)?n.top<0?"up":"down":n.left<0?"left":"right";t.position={top:a,left:c},t.directionChanged=t.direction!==m,t.delta=n,t.directionChanged===!0&&(t.direction=m,t.inflectionPoint=t.position),o("scroll",b({},t))}function d(){l=P(u,e.scrollTarget),l.addEventListener("scroll",r,h),r(!0)}function f(){l!==void 0&&(l.removeEventListener("scroll",r,h),l=void 0)}function r(a){if(a===!0||e.debounce===0||e.debounce==="0")s();else if(i===null){const[c,n]=e.debounce?[setTimeout(s,e.debounce),clearTimeout]:[requestAnimationFrame(s),cancelAnimationFrame];i=()=>{n(c),i=null}}}const g=V();return w(()=>{u=g.proxy.$el.parentNode,d()}),E(()=>{i!==null&&i(),f()}),Object.assign(g.proxy,{trigger:r,getPosition:()=>t}),M}});export{N as Q};
